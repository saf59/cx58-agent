
CREATE TYPE node_type_enum AS ENUM ('Root', 'Branch', 'ImageLeaf');

CREATE TABLE tree_nodes (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    parent_id UUID REFERENCES tree_nodes(id) ON DELETE CASCADE,
    node_type node_type_enum NOT NULL,
    -- autogenerated for ImageLeaf as from_updated(updated_at)
    name TEXT NULL,
    -- JSONB for flexible data storage
    data JSONB NOT NULL,
    -- Materialized path for efficient tree queries
    path TEXT NOT NULL,
    -- For ordering siblings
    sort_order INTEGER DEFAULT 0,
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    
);

CREATE INDEX idx_tree_nodes_parent_id ON tree_nodes(parent_id);
CREATE INDEX idx_tree_nodes_path ON tree_nodes USING BTREE(path);
CREATE INDEX idx_tree_nodes_type ON tree_nodes(node_type);
CREATE INDEX idx_tree_nodes_data_gin ON tree_nodes USING GIN(data);

CREATE TABLE node_access
(
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    user_id TEXT NOT NULL ,
    node_id UUID NOT NULL REFERENCES tree_nodes(id) ON DELETE CASCADE
);

CREATE INDEX idx_node_access_user_id ON node_access(user_id);
-- ============================================================================
-- Image Descriptions Cache
-- ============================================================================
CREATE TABLE image_descriptions (
    id UUID PRIMARY KEY DEFAULT uuidv7(), -- uuid_generate_v4(),
    node_id UUID NOT NULL REFERENCES tree_nodes(id) ON DELETE CASCADE,
    model_name TEXT NOT NULL,
    prompt TEXT NOT NULL,
    description TEXT NOT NULL,
    confidence FLOAT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(node_id, model_name, prompt)
);

CREATE INDEX idx_image_descriptions_node_id ON image_descriptions(node_id);

-- ============================================================================
-- Helper Functions
-- ============================================================================
CREATE OR REPLACE FUNCTION from_updated(
    updated_at TIMESTAMP,
    zone TEXT DEFAULT 'Europe/Berlin'
)
    RETURNS TEXT
    LANGUAGE plpgsql
    IMMUTABLE
AS $$
BEGIN
    -- Конвертируем timestamp в указанную timezone и форматируем
    RETURN to_char(
            updated_at AT TIME ZONE 'UTC' AT TIME ZONE zone,
            'DD.MM.YYYY HH24:MI:SS'
           );
END;
$$;

-- Function to get full tree path
CREATE OR REPLACE FUNCTION get_tree(req_user_id TEXT)
RETURNS TABLE(id UUID, parent_id UUID, node_type node_type_enum, name TEXT, data JSONB, path TEXT, sort_order INTEGER, updated_at TIMESTAMP , depth INTEGER, own BOOLEAN) AS $$
--    id, parent_id, node_type, name, data, path, sort_order, updated_at, depth, own

WITH RECURSIVE user_nodes AS (
    -- All nodes with access
    SELECT node_id
    FROM node_access
    WHERE user_id = req_user_id
),
               accessible_tree AS (
                   -- From the Root
                   SELECT
                       tn.id,
                       tn.parent_id,
                       tn.node_type,
                       COALESCE(tn.name,from_updated(tn.updated_at)) as name,
                       tn.data,
                       tn.path,
                       tn.sort_order,
                       tn.updated_at,
                       0 AS depth,
                       EXISTS(SELECT 1 FROM user_nodes un WHERE un.node_id = tn.id) AS own
                   FROM tree_nodes tn
                   WHERE tn.node_type = 'Root'

                   UNION ALL

                   -- RECURSIVE get childs
                   SELECT
                       tn.id,
                       tn.parent_id,
                       tn.node_type,
                       COALESCE(tn.name,from_updated(tn.updated_at)) as name,
                       tn.data,
                       tn.path,
                       tn.sort_order,
                       tn.updated_at,
                       at.depth + 1 AS depth,
                       CASE
                           WHEN EXISTS(SELECT 1 FROM user_nodes un WHERE un.node_id = tn.id) THEN true
                           ELSE at.own
                           END AS own
                   FROM tree_nodes tn
                            INNER JOIN accessible_tree at ON tn.parent_id = at.id
                   -- Show if 1. self is available
                   -- 2. parent is available (own = true)
                   WHERE at.own OR EXISTS(SELECT 1 FROM user_nodes un WHERE un.node_id = tn.id)
               )
SELECT
    id,
    parent_id,
    node_type,
    name,
    data,
    path,
    sort_order,
    updated_at,
    depth,
    own
FROM accessible_tree
ORDER BY path, sort_order;
$$ LANGUAGE SQL;

-- Function to get all children recursively
CREATE OR REPLACE FUNCTION get_tree_children(node_id UUID, max_depth INTEGER DEFAULT 10)
RETURNS TABLE(id UUID, parent_id UUID, node_type node_type_enum, data JSONB, depth INTEGER) AS $$
    WITH RECURSIVE tree_children AS (
        SELECT
            t.id,
            t.parent_id,
            t.node_type,
            t.data,
            0 as depth
        FROM tree_nodes t
        WHERE t.id = node_id

        UNION ALL

        SELECT
            t.id,
            t.parent_id,
            t.node_type,
            t.data,
            tc.depth + 1
        FROM tree_nodes t
        INNER JOIN tree_children tc ON t.parent_id = tc.id
        WHERE tc.depth < max_depth
    )
    SELECT * FROM tree_children;
$$ LANGUAGE SQL;
--
CREATE OR REPLACE FUNCTION get_full_node_name(p_node_id UUID)
    RETURNS TEXT
    LANGUAGE plpgsql
    STABLE
AS $$
DECLARE
    v_full_name TEXT;
BEGIN
    WITH RECURSIVE node_path AS (
        SELECT
            id,
            parent_id,
            COALESCE(name, from_updated(updated_at)) AS name,
            0 AS level
        FROM tree_nodes
        WHERE id = p_node_id

        UNION ALL

        SELECT
            tn.id,
            tn.parent_id,
            COALESCE(tn.name, from_updated(tn.updated_at)) AS name,
            np.level + 1 AS level
        FROM tree_nodes tn
                 INNER JOIN node_path np ON tn.id = np.parent_id
    )
    SELECT
        string_agg(name, '/' ORDER BY level DESC)
    INTO v_full_name
    FROM node_path;

    RETURN v_full_name;
END;
$$;
-- SELECT get_full_node_name('e839dfae-2cf6-4ac4-a1c5-6213739bfaa9'); -- is Root/B/12.12.2025 19:38:11
-- Function to update materialized path on insert/update
CREATE OR REPLACE FUNCTION update_tree_path()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.parent_id IS NULL THEN
        NEW.path := NEW.id::TEXT;
    ELSE
        SELECT path || '.' || NEW.id::TEXT INTO NEW.path
        FROM tree_nodes
        WHERE id = NEW.parent_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tree_nodes_path_trigger
    BEFORE INSERT OR UPDATE ON tree_nodes
    FOR EACH ROW
    EXECUTE FUNCTION update_tree_path();

-- Function to prevent circular references
CREATE OR REPLACE FUNCTION prevent_circular_tree()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.parent_id IS NOT NULL THEN
        IF EXISTS (
            SELECT 1 FROM tree_nodes
            WHERE id = NEW.parent_id
            AND path LIKE NEW.id::TEXT || '%'
        ) THEN
            RAISE EXCEPTION 'Circular reference detected';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tree_nodes_circular_check
    BEFORE INSERT OR UPDATE ON tree_nodes
    FOR EACH ROW
    EXECUTE FUNCTION prevent_circular_tree();

